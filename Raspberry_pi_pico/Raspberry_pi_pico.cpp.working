// Hardware Connections:
//
// INMP441 Microphone:
// - VDD  -> 3.3V (Pin 36 on Pico)
// - GND  -> GND  (Pin 38 on Pico)
// - SD   -> GP20 (Pin 26 on Pico) [DATA]
// - SCK  -> GP18 (Pin 24 on Pico) [BCLK]
// - WS   -> GP19 (Pin 25 on Pico) [LRCLK]
// - L/R  -> GND  (for left channel)
//
// LED Connection:
// - Anode   -> GP22 (Pin 29 on Pico) through a 220Ω resistor
// - Cathode -> GND  (any GND pin on Pico)
//
// FTDI Module Connection:
// - FTDI RX -> GP0 (Pin 1 on Pico, UART0 TX)
// - FTDI TX -> GP1 (Pin 2 on Pico, UART0 RX)
// - FTDI VCC -> 3.3V (Pin 36 on Pico)
// - FTDI GND -> GND (Pin 38 on Pico)
//
// NEO-6M GPS Module Connection:
// - VCC -> 3.3V (Pin 36 on Pico)
// - GND -> GND (Pin 38 on Pico)
// - TX  -> GP5 (Pin 7 on Pico, UART1 RX)
// - RX  -> GP4 (Pin 6 on Pico, UART1 TX)
//
// NRF24L01 Module Connection:
// - VCC -> 3.3V (Pin 36 on Pico)
// - GND -> GND (Pin 38 on Pico)
// - SCK -> GP10 (Pin 14 on Pico)
// - MOSI -> GP11 (Pin 15 on Pico)
// - MISO -> GP12 (Pin 16 on Pico)
// - CSN -> GP13 (Pin 17 on Pico)
// - CE -> GP14 (Pin 19 on Pico)

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>  // For strncmp
#include <math.h>    // For fabs
#include <time.h>    // For time functions
#include "pico/stdlib.h"
#include "pico/multicore.h"
#include "pico/mutex.h"
#include "hardware/gpio.h"
#include "hardware/pio.h"
#include "hardware/dma.h"
#include "hardware/clocks.h"
#include "hardware/uart.h"
#include "hardware/spi.h"
#include "model_handler.h" 
#include "gps_handler.h"

// Constants
#define UART_GPS uart1
#define UART_GPS_TX_PIN 4
#define UART_GPS_RX_PIN 5

// Configuration defines for UART and GPIO
#define UART_TX_PIN 0
#define UART_RX_PIN 1
#define UART_ID uart0
#define BAUD_RATE 115200
#define DATA_BITS 8
#define STOP_BITS 1
#define PARITY    UART_PARITY_NONE

// GPS Configuration
#define GPS_UART_ID uart1
#define GPS_UART_TX_PIN 4
#define GPS_UART_RX_PIN 5
#define GPS_BAUD_RATE 9600
#define GPS_DATA_BITS 8
#define GPS_STOP_BITS 1
#define GPS_PARITY    UART_PARITY_NONE
#define GPS_BUFFER_SIZE 256

// GPIO Configuration
#define INMP441_SCK_PIN 18  // BCLK
#define INMP441_WS_PIN  19  // LRCLK/WS
#define INMP441_SD_PIN  20  // DATA
#define LED_INBUILT_IN 25   // Built-in LED
#define LED_PIN 22         // External LED for gunshot indication

// Audio Configuration
#define SAMPLE_RATE 16000
#define SAMPLE_BUFFER_SIZE 1024
#define DMA_CHANNEL 0
#define INMP441_PIO pio0
#define INMP441_SM  0
#define DEBUG_SAMPLES 32
#define MIC_TEST_DURATION_MS 5000

// NRF24L01 Configuration
#define NRF_SPI_PORT spi0
#define NRF_SCK_PIN 10  // SPI Clock
#define NRF_MOSI_PIN 11 // SPI MOSI
#define NRF_MISO_PIN 12 // SPI MISO
#define NRF_CSN_PIN 13  // SPI Chip Select
#define NRF_CE_PIN 14   // Chip Enable

#define NODE_ID "01"    // Node identifier
#define MAX_PAYLOAD_SIZE 32  // NRF24L01 max payload size

// Create GPS handler instance
static GPSHandler gps_handler(GPS_UART_ID, GPS_UART_TX_PIN, GPS_UART_RX_PIN);

// GPS location structure
struct gps_location_t {
    bool valid;
    float latitude;
    float longitude;
} g_current_location = {false, 0.0f, 0.0f};

// Message structure for transmitting data
typedef struct {
    char node_id[3];        // 2 chars + null terminator
    char date[11];          // DD/MM/YYYY + null terminator
    char time[9];           // HH:MM:SS + null terminator
    char latitude[12];      // Including decimal point and sign
    char longitude[12];     // Including decimal point and sign
    float confidence;
} gunshot_message_t;


// GPS Message types we're interested in
#define NMEA_GPRMC "$GPRMC"
#define NMEA_GPGGA "$GPGGA"

// Global variables and mutex
static mutex_t printf_mutex;
volatile bool core1_ready = false;
volatile bool gunshot_detected = false;

// GPS globals
static char gps_buffer[GPS_BUFFER_SIZE];
static uint line_pos = 0;  // Current position in line buffer
static mutex_t gps_mutex;
static bool start_of_sentence = false;
static uint32_t last_valid_sentence = 0;
static uint32_t sentence_count = 0;
static bool valid_gps_data = false;
static float latitude = 0.0f;
static float longitude = 0.0f;

// Forward declarations
void init_sync(void);
void safe_uart_puts(const char* str);
void safe_printf(const char* format, ...);
void init_uart(void);
bool init_microphone(void);
void core1_entry(void);
bool test_microphone(void);
static inline void configure_dma(void);
void init_gps(void);
void process_gps(void);
bool wait_for_gps_fix(uint32_t timeout_ms);
void init_nrf24l01(void);
void nrf24l01_send_message(const char* message);
void create_json_message(char* buffer, size_t buffer_size, const gunshot_message_t* msg);

// Convert NMEA coordinate format to decimal degrees
float nmea_to_decimal_degrees(float nmea_coord, char direction) {
    // Extract degrees (before decimal) and minutes (after decimal)
    int degrees = (int)(nmea_coord / 100.0f);  // First 2 or 3 digits
    float minutes = nmea_coord - (degrees * 100.0f);  // Remaining digits
    float decimal = degrees + (minutes / 60.0f);  // Convert minutes to decimal degrees
    
    char buf[64];
    snprintf(buf, sizeof(buf), "NMEA Convert: %.6f %c -> %d° %.4f' = %.6f°\r\n", 
             nmea_coord, direction, degrees, minutes, decimal);
    safe_uart_puts(buf);
    
    return (direction == 'S' || direction == 'W') ? -decimal : decimal;
}

// Parse GPRMC sentence
// Returns true if parsing successful and fix is valid
bool parse_gprmc(const char* sentence, float* out_lat, float* out_lon, bool* out_valid) {
    char field_buffer[32];  // Increased buffer for safety
    const char* ptr = sentence;
    int field = 0;
    int pos = 0;
    float nmea_lat = 0, nmea_lon = 0;
    char lat_dir = 'N', lon_dir = 'E';
    *out_valid = false;

    safe_uart_puts("\r\nParsing GPRMC: ");
    safe_uart_puts(sentence);
    safe_uart_puts("\r\n");

    // Skip $GPRMC
    while (*ptr && *ptr != ',') ptr++;
    if (!*ptr) return false;
    ptr++;

    // Parse fields
    while (*ptr && field < 7) {  // We only need first 7 fields
        if (*ptr == ',' || *ptr == '*') {
            field_buffer[pos] = '\0';
            
            char buf[128];
            snprintf(buf, sizeof(buf), "Field %d: [%s]\r\n", field, field_buffer);
            safe_uart_puts(buf);
            
            switch(field) {
                case 1:  // Status
                    *out_valid = (field_buffer[0] == 'A');
                    break;
                case 2:  // Latitude DDMM.MMMMM
                    nmea_lat = atof(field_buffer);
                    break;
                case 3:  // N/S
                    lat_dir = field_buffer[0];
                    break;
                case 4:  // Longitude DDDMM.MMMMM
                    nmea_lon = atof(field_buffer);
                    break;
                case 5:  // E/W
                    lon_dir = field_buffer[0];
                    break;
            }
            pos = 0;
            field++;
            ptr++;
            continue;
        }
        if (pos < sizeof(field_buffer) - 1) {
            field_buffer[pos++] = *ptr;
        }
        ptr++;
    }

    if (*out_valid) {
        *out_lat = nmea_to_decimal_degrees(nmea_lat, lat_dir);
        *out_lon = nmea_to_decimal_degrees(nmea_lon, lon_dir);
        
        char buf[128];
        snprintf(buf, sizeof(buf), "Parsed position: %.6f%c, %.6f%c\r\n", 
                 *out_lat, lat_dir, *out_lon, lon_dir);
        safe_uart_puts(buf);
        return true;
    }
    
    safe_uart_puts("Invalid fix\r\n");
    return false;
}

// Audio buffer
static int32_t audio_buffer[SAMPLE_BUFFER_SIZE];

// Include PIO program
#include "inmp441.pio.h"

// DMA configuration
static inline void configure_dma(void) {
    safe_uart_puts("   Starting DMA configuration...\r\n");
    
    // Get default channel configuration
    dma_channel_config c = dma_channel_get_default_config(DMA_CHANNEL);
    
    char buf[64];
    snprintf(buf, sizeof(buf), "   Got default DMA config for channel %d\r\n", DMA_CHANNEL);
    safe_uart_puts(buf);
    
    // Configure channel
    channel_config_set_read_increment(&c, false);  // Don't increment read address (reading from same PIO FIFO)
    channel_config_set_write_increment(&c, true);  // Do increment write address (writing to buffer)
    channel_config_set_transfer_data_size(&c, DMA_SIZE_32);  // Transfer 32-bit words
    channel_config_set_dreq(&c, pio_get_dreq(INMP441_PIO, INMP441_SM, false));  // Pace transfers based on PIO

    dma_channel_configure(
        DMA_CHANNEL,
        &c,
        audio_buffer,                    // Destination pointer
        &INMP441_PIO->rxf[INMP441_SM],  // Source pointer
        SAMPLE_BUFFER_SIZE,              // Number of transfers
        true                            // Start immediately
    );
}

// Initialize mutex for printf synchronization
void init_sync(void) {
    mutex_init(&printf_mutex);
}

// Safe UART output function
void safe_uart_puts(const char* str) {
    mutex_enter_blocking(&printf_mutex);
    uart_puts(UART_ID, str);
    mutex_exit(&printf_mutex);
}

// Safe printf function
void safe_printf(const char* format, ...) {
    mutex_enter_blocking(&printf_mutex);
    va_list args;
    va_start(args, format);
    vprintf(format, args);
    va_end(args);
    mutex_exit(&printf_mutex);
}

// Initialize UART for FTDI communication
void init_uart(void) {
    uart_init(UART_ID, BAUD_RATE);
    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);
    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);
    uart_set_hw_flow(UART_ID, false, false);
    uart_set_format(UART_ID, DATA_BITS, STOP_BITS, PARITY);
    uart_set_fifo_enabled(UART_ID, false);
    uart_puts(UART_ID, "\r\n\nUART Test - If you see this, UART is working!\r\n");
    
    // Initialize model handler
    int init_status = model_init();
    if (init_status != 0) {
        safe_uart_puts("ERROR: Failed to initialize model handler\r\n");
    } else {
        safe_uart_puts("Model handler initialized successfully\r\n");
    }
}

// Override putchar for printf redirection to UART with mutex protection
int putchar(int ch) {
    mutex_enter_blocking(&printf_mutex);
    uart_putc(UART_ID, (char)ch);
    mutex_exit(&printf_mutex);
    return ch;
}

// Test microphone connectivity
bool test_microphone() {
    safe_uart_puts("\r\nStarting microphone test...\r\n");
    safe_uart_puts("\r\nTesting INMP441 Microphone:\r\n");
    safe_uart_puts("1. Checking PIO configuration...\r\n");
    safe_uart_puts("Checking PIO program size...\r\n");
    
    if (!pio_can_add_program(INMP441_PIO, &inmp441_program)) {
        safe_uart_puts("ERROR: Cannot load PIO program - insufficient space\r\n");
        return false;
    }
    
    safe_uart_puts("2. Loading PIO program...\r\n");
    uint offset = pio_add_program(INMP441_PIO, &inmp441_program);
    
    char buf[128];
    snprintf(buf, sizeof(buf), "   Program loaded at offset %u\r\n", offset);
    safe_uart_puts(buf);
    
    safe_uart_puts("3. Initializing GPIO pins...\r\n");
    snprintf(buf, sizeof(buf), "   SCK (BCLK): GPIO %d\r\n", INMP441_SCK_PIN);
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "   WS (LRCLK): GPIO %d\r\n", INMP441_WS_PIN);
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "   SD (DATA):  GPIO %d\r\n", INMP441_SD_PIN);
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "   Sample Rate: %d Hz\r\n", SAMPLE_RATE);
    safe_uart_puts(buf);
    
    // Initialize the PIO state machine
    snprintf(buf, sizeof(buf), "   Initializing PIO state machine %d on PIO%d\r\n", 
             INMP441_SM, (INMP441_PIO == pio0) ? 0 : 1);
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "   Clock frequency: %lu Hz\r\n", clock_get_hz(clk_sys));
    safe_uart_puts(buf);
    
    inmp441_program_init(INMP441_PIO, INMP441_SM, offset, SAMPLE_RATE, INMP441_SD_PIN, INMP441_SCK_PIN);
    safe_uart_puts("   PIO initialization complete\r\n");
    
    safe_uart_puts("4. Configuring DMA...\r\n");
    snprintf(buf, sizeof(buf), "   DMA Channel: %d\r\n", DMA_CHANNEL);
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "   Buffer size: %d samples\r\n", SAMPLE_BUFFER_SIZE);
    safe_uart_puts(buf);
    configure_dma();
    safe_uart_puts("   DMA configuration complete\r\n");
    
    safe_uart_puts("5. Starting audio capture test...\r\n");
    safe_uart_puts("   Please make some noise near the microphone!\r\n\r\n");
    
    uint32_t start_time = to_ms_since_boot(get_absolute_time());
    bool received_audio = false;
    int32_t min_sample = 0x7FFFFFFF;
    int32_t max_sample = -0x7FFFFFFF;
    
    while (to_ms_since_boot(get_absolute_time()) - start_time < MIC_TEST_DURATION_MS) {
        safe_uart_puts("   Waiting for DMA transfer...\r\n");
        dma_channel_wait_for_finish_blocking(DMA_CHANNEL);
        safe_uart_puts("   DMA transfer complete\r\n");
        
        // Process samples
        for (int i = 0; i < DEBUG_SAMPLES; i++) {
            int32_t sample = audio_buffer[i] >> 8;  // Convert to 24-bit
            if (sample != 0) {
                received_audio = true;
            }
            if (sample < min_sample) min_sample = sample;
            if (sample > max_sample) max_sample = sample;
            
            if (i < 8) { // Print first 8 samples
                snprintf(buf, sizeof(buf), "Sample %d: %ld\r\n", i, sample);
                safe_uart_puts(buf);
            }
        }
        
        // Restart DMA
        dma_channel_set_write_addr(DMA_CHANNEL, audio_buffer, true);
        
        if (received_audio) {
            break;  // Got some samples, no need to wait longer
        }
    }
    
    safe_uart_puts("\r\nMicrophone Test Results:\r\n");
    snprintf(buf, sizeof(buf), "- Audio data received: %s\r\n", received_audio ? "YES" : "NO");
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "- Min sample value: %ld\r\n", min_sample);
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "- Max sample value: %ld\r\n", max_sample);
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "- Sample range: %ld\r\n", max_sample - min_sample);
    safe_uart_puts(buf);
    
    if (!received_audio) {
        safe_uart_puts("\r\nERROR: No audio data received. Please check:\r\n");
        safe_uart_puts("1. All connections are secure\r\n");
        safe_uart_puts("2. VDD and GND are properly connected\r\n");
        safe_uart_puts("3. L/R pin is connected to GND\r\n");
        return false;
    }
    
    if (max_sample - min_sample < 1000) {
        safe_uart_puts("\r\nWARNING: Very low audio range detected.\r\n");
        safe_uart_puts("Try making louder sounds near the microphone.\r\n");
    } else {
        safe_uart_puts("\r\nMicrophone test PASSED! ✓\r\n");
    }
    
    return true;
}

// Initialize INMP441 microphone
bool init_microphone() {
    // First run the test
    if (!test_microphone()) {
        safe_uart_puts("\r\nMicrophone initialization failed! Check connections and try again.\r\n");
        return false;
    }
    
    // No need to reconfigure since test_microphone already set everything up
    return true;
}

// Initialize UART for GPS
void gps_uart_irq_handler() {
    while (uart_is_readable(UART_GPS)) {
        uint8_t ch = uart_getc(UART_GPS);
        
        // Echo character to debug UART
        uart_putc(UART_ID, ch);
        
        // Store in buffer for NMEA sentence processing
        if (line_pos < GPS_BUFFER_SIZE - 1) {
            gps_buffer[line_pos++] = ch;
            
            // Check for line ending
            if (ch == '\n' || ch == '\r') {
                if (line_pos > 1) {  // Ensure we have more than just the newline
                    gps_buffer[line_pos] = '\0';  // Null terminate
                    process_gps();  // Process the complete NMEA sentence
                }
                line_pos = 0;  // Reset for next sentence
            }
        } else {
            // Buffer overflow - reset
            line_pos = 0;
        }
    }
}

void init_gps(void) {
    safe_uart_puts("\r\n=== GPS Initialization Starting ===\r\n");
    
    // Initialize UART for GPS
    uart_init(UART_GPS, GPS_BAUD_RATE);
    uart_set_hw_flow(UART_GPS, false, false);
    uart_set_format(UART_GPS, GPS_DATA_BITS, GPS_STOP_BITS, GPS_PARITY);
    
    // Set UART pins
    gpio_set_function(UART_GPS_TX_PIN, GPIO_FUNC_UART);
    gpio_set_function(UART_GPS_RX_PIN, GPIO_FUNC_UART);
    
    // Force immediate RX, no buffering
    uart_set_fifo_enabled(UART_GPS, false);
    
    // Reset UART and clear any pending data
    uart_is_readable(UART_GPS);  // Clear RX flag
    while (uart_is_readable(UART_GPS)) {
        uart_getc(UART_GPS);  // Clear any pending data
    }
    
    // Initialize mutex
    mutex_init(&gps_mutex);
    
    // Set up and enable interrupt handler
    int UART_GPS_IRQ = UART1_IRQ;  // UART1 for GPS
    irq_set_exclusive_handler(UART_GPS_IRQ, gps_uart_irq_handler);
    irq_set_enabled(UART_GPS_IRQ, true);
    
    // Enable UART to send interrupts - RX only
    uart_set_irq_enables(UART_GPS, true, false);
    
    safe_uart_puts("GPS UART initialized with interrupt handling\r\n");
    safe_uart_puts("All received characters will be echoed:\r\n\r\n");
}

bool wait_for_gps_fix(uint32_t timeout_ms) {
    uint32_t start = to_ms_since_boot(get_absolute_time());
    uint32_t last_print = start;
    uint32_t last_status = start;
    const uint32_t PRINT_INTERVAL = 1000;   // Status update every second
    const uint32_t STATUS_INTERVAL = 100;   // Detailed status every 100ms

    char buf[256];  // Buffer for formatting messages

    // Print initial status
    snprintf(buf, sizeof(buf), "\r\n=== Starting GPS Fix Wait ===\r\n");
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "Timeout set to: %lu ms\r\n", timeout_ms);
    safe_uart_puts(buf);

    int attempts = 0;
    while (!g_current_location.valid) {
        attempts++;
        uint32_t now = to_ms_since_boot(get_absolute_time());

        // Print detailed status more frequently
        if (now - last_status >= STATUS_INTERVAL) {
            snprintf(buf, sizeof(buf), "\r\nGPS Status:\r\n");
            safe_uart_puts(buf);
            snprintf(buf, sizeof(buf), "- Valid: %s\r\n", g_current_location.valid ? "YES" : "NO");
            safe_uart_puts(buf);
            snprintf(buf, sizeof(buf), "- Attempts: %d\r\n", attempts);
            safe_uart_puts(buf);
            snprintf(buf, sizeof(buf), "- Time elapsed: %lu ms\r\n", now - start);
            safe_uart_puts(buf);
            last_status = now;
        }

        // Process GPS data with status message
        snprintf(buf, sizeof(buf), "\r\nProcessing GPS data (attempt %d)...\r\n", attempts);
        safe_uart_puts(buf);
        process_gps();
        
        // Print waiting message
        if (now - last_print >= PRINT_INTERVAL) {
            snprintf(buf, sizeof(buf), "\r\nWaiting for GPS fix... %d seconds elapsed\r\n",
                    (now - start) / 1000);
            safe_uart_puts(buf);
            last_print = now;
        }
        
        // Check timeout
        if (now - start >= timeout_ms) {
            snprintf(buf, sizeof(buf), "\r\n*** GPS Fix Timeout ***\r\n");
            safe_uart_puts(buf);
            snprintf(buf, sizeof(buf), "- Time elapsed: %d seconds\r\n", timeout_ms / 1000);
            safe_uart_puts(buf);
            snprintf(buf, sizeof(buf), "- Total attempts: %d\r\n", attempts);
            safe_uart_puts(buf);
            snprintf(buf, sizeof(buf), "- Last known state:\r\n");
            safe_uart_puts(buf);
            snprintf(buf, sizeof(buf), "  Valid: %s\r\n", g_current_location.valid ? "YES" : "NO");
            safe_uart_puts(buf);
            snprintf(buf, sizeof(buf), "  Latitude: %.6f\r\n", g_current_location.latitude);
            safe_uart_puts(buf);
            snprintf(buf, sizeof(buf), "  Longitude: %.6f\r\n", g_current_location.longitude);
            safe_uart_puts(buf);
            return false;
        }
        
        sleep_ms(50);  // Check more frequently but don't hog CPU
    }
    
    // GPS fix obtained!
    uint32_t end = to_ms_since_boot(get_absolute_time());
    snprintf(buf, sizeof(buf), "\r\n=== GPS Fix Obtained! ===\r\n");
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "- Time taken: %lu ms\r\n", end - start);
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "- Total attempts: %d\r\n", attempts);
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "- Position:\r\n");
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "  Latitude: %.6f\r\n", g_current_location.latitude);
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "  Longitude: %.6f\r\n", g_current_location.longitude);
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "=========================\r\n\r\n");
    safe_uart_puts(buf);
    return true;
}

// Initialize NRF24L01 module
void init_nrf24l01(void) {
    // Reset chip
    gpio_init(NRF_CE_PIN);
    gpio_set_dir(NRF_CE_PIN, GPIO_OUT);
    gpio_put(NRF_CE_PIN, false);
    sleep_ms(10);
    
    // Configure SPI
    spi_init(NRF_SPI_PORT, 4000000);  // 4 MHz
    gpio_set_function(NRF_SCK_PIN, GPIO_FUNC_SPI);
    gpio_set_function(NRF_MOSI_PIN, GPIO_FUNC_SPI);
    gpio_set_function(NRF_MISO_PIN, GPIO_FUNC_SPI);
    
    // Configure CSN pin
    gpio_init(NRF_CSN_PIN);
    gpio_set_dir(NRF_CSN_PIN, GPIO_OUT);
    gpio_put(NRF_CSN_PIN, true);  // Deselect
    
    // Configure CE pin
    gpio_init(NRF_CE_PIN);
    gpio_set_dir(NRF_CE_PIN, GPIO_OUT);
    gpio_put(NRF_CE_PIN, false);  // Power down
    
    // Give some time for the module to settle
    sleep_ms(100);
    
    safe_uart_puts("NRF24L01 module initialized\r\n");
}

// Send message via NRF24L01
void nrf24l01_send_message(const char* message) {
    gpio_put(NRF_CSN_PIN, false);  // Select the NRF24L01
    sleep_us(10);
    
    // Write message payload
    for (size_t i = 0; i < strlen(message); i++) {
        spi_write_blocking(NRF_SPI_PORT, (const uint8_t*)&message[i], 1);
    }
    
    gpio_put(NRF_CSN_PIN, true);   // Deselect the NRF24L01
    
    safe_uart_puts("Message sent via NRF24L01\r\n");
}

// Create JSON message from data
void create_json_message(char* buffer, size_t buffer_size, const gunshot_message_t* msg) {
    snprintf(buffer, buffer_size, 
            "{\"node_id\":\"%s\",\"date\":\"%s\",\"time\":\"%s\",\"latitude\":\"%s\",\"longitude\":\"%s\",\"confidence\":%.2f}",
            msg->node_id, msg->date, msg->time, msg->latitude, msg->longitude, msg->confidence);
}

// Core 1 entry point - Audio processing
void core1_entry() {
    safe_uart_puts("\r\nCore 1: Starting...\r\n");
    sleep_ms(100); // Give time for UART message
    
    safe_uart_puts("Core 1: Initializing microphone...\r\n");
    sleep_ms(100); // Give time for UART message
    
    // Initialize microphone
    safe_uart_puts("Core 1: Starting microphone initialization...\r\n");
    bool init_success = init_microphone();
    safe_uart_puts("Core 1: Microphone initialization attempt complete\r\n");
    
    if (!init_success) {
        safe_uart_puts("Core 1: Microphone initialization failed\r\n");
        safe_uart_puts("Core 1: Check hardware connections and try again\r\n");
        core1_ready = true;  // Signal core0 even on failure so it doesn't hang
        while (true) {
            gpio_put(LED_PIN, true);   // Error indication pattern
            sleep_ms(100);
            gpio_put(LED_PIN, false);
            sleep_ms(900);             // Blink once per second to show core is alive
        }
    }
    
    safe_uart_puts("Core 1: Microphone initialized successfully\r\n");
    core1_ready = true;  // Signal core0 that we're ready
    
    while (true) {
        // Wait for DMA transfer to complete
        dma_channel_wait_for_finish_blocking(DMA_CHANNEL);
        
        // Process audio data using the model
        bool detection = model_process_audio(audio_buffer, SAMPLE_BUFFER_SIZE);
        float confidence = model_get_confidence();
        
        // Print amplitude level every 1000ms (1 second)
        static uint32_t last_print = 0;
        uint32_t now = to_ms_since_boot(get_absolute_time());
        if (now - last_print > 1000) {
            char buf[64];
            snprintf(buf, sizeof(buf), "\r\nAudio Confidence: %.2f\r\n", confidence);
            safe_uart_puts(buf);
            last_print = now;
        }

        // Map confidence to LED brightness
        uint8_t led_brightness = (uint8_t)(confidence * 255);
        gpio_put(LED_PIN, led_brightness > 50);
        
        // If detection threshold exceeded, trigger gunshot detection
        if (detection) {
            gunshot_detected = true;
            char buf[64];
            snprintf(buf, sizeof(buf), "GUNSHOT DETECTED! Confidence: %.2f\r\n", confidence);
            safe_uart_puts(buf);
            
            // Prepare and send message via NRF24L01
            gunshot_message_t msg;
            strncpy(msg.node_id, NODE_ID, sizeof(msg.node_id) - 1);
            msg.node_id[sizeof(msg.node_id) - 1] = '\0';  // Ensure null termination
            
            // Get current time
            time_t now = time(NULL);
            struct tm *t = localtime(&now);
            strftime(msg.date, sizeof(msg.date), "%d/%m/%Y", t);
            strftime(msg.time, sizeof(msg.time), "%H:%M:%S", t);
            
            // Set latitude, longitude, and confidence
            snprintf(msg.latitude, sizeof(msg.latitude), "%.6f", latitude);
            snprintf(msg.longitude, sizeof(msg.longitude), "%.6f", longitude);
            msg.confidence = confidence;
            
            // Create JSON message
            char json_buffer[256];
            create_json_message(json_buffer, sizeof(json_buffer), &msg);
            
            // Send message
            nrf24l01_send_message(json_buffer);
            
            sleep_ms(1000); // Prevent multiple detections
            gunshot_detected = false;
        }
        
        // Restart DMA transfer
        dma_channel_set_write_addr(DMA_CHANNEL, audio_buffer, true);
    }
}

// Core 0 entry point - LED control
int main() {
    // Initialize synchronization first
    init_sync();
    
    // Initialize LED for visual debugging
    gpio_init(LED_INBUILT_IN);
    gpio_set_dir(LED_INBUILT_IN, GPIO_OUT);
    gpio_put(LED_INBUILT_IN, true);  // Turn on built-in LED
    
    // Initialize UART
    init_uart();
    sleep_ms(1000); // Give UART time to stabilize
    
    // Initialize external LED
    gpio_init(LED_PIN);
    gpio_set_dir(LED_PIN, GPIO_OUT);
    
    safe_uart_puts("\r\n=== Program Starting (GPS Debug Mode) ===\r\n");
    safe_uart_puts("Initializing...\r\n");

    // Initialize GPS first
    safe_uart_puts("Initializing GPS...\r\n");
    init_gps();
    safe_uart_puts("Starting GPS monitoring...\r\n");
    
    // Wait for initial GPS fix with timeout
    safe_uart_puts("Waiting for initial GPS fix (timeout: 60 seconds)...\r\n");
    if (wait_for_gps_fix(60000)) {  // 60 second timeout for first fix
        safe_uart_puts("GPS fix acquired successfully!\r\n");
    } else {
        safe_uart_puts("GPS fix timeout - continuing without initial fix.\r\n");
    }
    
    /* Temporarily disabled Core 1 for GPS debugging
    // Launch Core 1
    safe_uart_puts("Starting Core 1...\r\n");
    multicore_launch_core1(core1_entry);
    
    // Wait for Core 1 to initialize with timeout
    uint32_t start_time = to_ms_since_boot(get_absolute_time());
    while (!core1_ready) {
        // Blink LED while waiting
        gpio_put(LED_INBUILT_IN, true);
        sleep_ms(100);
        gpio_put(LED_INBUILT_IN, false);
        sleep_ms(100);
        
        // Timeout after 10 seconds
        if (to_ms_since_boot(get_absolute_time()) - start_time > 10000) {
            safe_uart_puts("ERROR: Core 1 initialization timeout!\r\n");
            break;
        }
    }
    
    if (core1_ready) {
        safe_uart_puts("Core 1 initialized successfully\r\n");
    }
    */
    
    // Initialize NRF24L01
    init_nrf24l01();
    
    // Main loop - GPS debug mode
    safe_uart_puts("\r\n=== Entering GPS Debug Mode ===\r\n");
    safe_uart_puts("Monitoring GPS data...\r\n\r\n");
    
    while (true) {
        // Heartbeat LED - now we can use a longer delay since GPS is handled by interrupts
        gpio_put(LED_INBUILT_IN, !gpio_get(LED_INBUILT_IN));  // Toggle LED
        sleep_ms(500);  // 1Hz blink to show main loop is running
    }
    
    return 0;  // Never reached
}

// Process GPS data - Now called from interrupt handler for complete sentences
void process_gps() {
    uint32_t now = to_ms_since_boot(get_absolute_time());
    
    // Check for GPRMC sentence
    if (strncmp(gps_buffer, "$GPRMC", 6) == 0) {
        sentence_count++;
        float lat, lon;
        bool valid;
        
        if (parse_gprmc(gps_buffer, &lat, &lon, &valid)) {
            mutex_enter_blocking(&gps_mutex);
            g_current_location.valid = valid;
            if (valid) {
                g_current_location.latitude = lat;
                g_current_location.longitude = lon;
                valid_gps_data = true;
                latitude = lat;
                longitude = lon;
                last_valid_sentence = now;
            }
            mutex_exit(&gps_mutex);
        }
    }
    
    // Print periodic status if we haven't had a valid sentence in a while
    static uint32_t last_status = 0;
    if (now - last_status >= 5000) {  // Every 5 seconds
        safe_printf("\r\n[GPS] Status: Sentences: %lu, Last valid: %lu ms ago\r\n", 
                   sentence_count,
                   now - last_valid_sentence);
        last_status = now;
    }
}



