// Hardware Connections:
//
// INMP441 Microphone:
// - VDD  -> 3.3V (Pin 36 on Pico)
// - GND  -> GND  (Pin 38 on Pico)
// - SD   -> GP20 (Pin 26 on Pico) [DATA]
// - SCK  -> GP18 (Pin 24 on Pico) [BCLK]
// - WS   -> GP19 (Pin 25 on Pico) [LRCLK]
// - L/R  -> GND  (for left channel)
//
// LED Connection:
// - Anode   -> GP22 (Pin 29 on Pico) through a 220Î© resistor
// - Cathode -> GND  (any GND pin on Pico)
//
// FTDI Module Connection:
// - FTDI RX -> GP0 (Pin 1 on Pico, UART0 TX)
// - FTDI TX -> GP1 (Pin 2 on Pico, UART0 RX)
// - FTDI VCC -> 3.3V (Pin 36 on Pico)
// - FTDI GND -> GND (Pin 38 on Pico)
//
// NEO-6M GPS Module Connection:
// - VCC -> 3.3V (Pin 36 on Pico)
// - GND -> GND (Pin 38 on Pico)
// - TX  -> GP5 (Pin 7 on Pico, UART1 RX)
// - RX  -> GP4 (Pin 6 on Pico, UART1 TX)
//
// NRF24L01 Module Connection:
// - VCC -> 3.3V (Pin 36 on Pico)
// - GND -> GND (Pin 38 on Pico)
// - SCK -> GP10 (Pin 14 on Pico)
// - MOSI -> GP11 (Pin 15 on Pico)
// - MISO -> GP12 (Pin 16 on Pico)
// - CSN -> GP13 (Pin 17 on Pico)
// - CE -> GP14 (Pin 19 on Pico)

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>  // For strncmp
#include <math.h>    // For fabs
#include <time.h>    // For time functions
#include "pico/stdlib.h"
#include "pico/multicore.h"
#include "pico/mutex.h"
#include "hardware/gpio.h"
#include "hardware/pio.h"
#include "hardware/dma.h"
#include "hardware/clocks.h"
#include "hardware/uart.h"
#include "hardware/spi.h"
#include "model_handler.h" 

// Configuration defines
#define UART_TX_PIN 0
#define UART_RX_PIN 1
#define UART_ID uart0
#define BAUD_RATE 115200
#define DATA_BITS 8
#define STOP_BITS 1
#define PARITY    UART_PARITY_NONE

// GPIO Configuration
#define INMP441_SCK_PIN 18  // BCLK
#define INMP441_WS_PIN  19  // LRCLK/WS
#define INMP441_SD_PIN  20  // DATA
#define LED_INBUILT_IN 25   // Built-in LED
#define LED_PIN 22         // External LED for gunshot indication

// Audio Configuration
#define SAMPLE_RATE 16000
#define SAMPLE_BUFFER_SIZE 1024
#define DMA_CHANNEL 0
#define INMP441_PIO pio0
#define INMP441_SM  0
#define DEBUG_SAMPLES 32
#define MIC_TEST_DURATION_MS 5000

// GPS Configuration
#define GPS_UART_ID uart1
#define GPS_UART_TX_PIN 4
#define GPS_UART_RX_PIN 5
#define GPS_BAUD_RATE 9600
#define GPS_DATA_BITS 8
#define GPS_STOP_BITS 1
#define GPS_PARITY    UART_PARITY_NONE
#define GPS_BUFFER_SIZE 256

// NRF24L01 Configuration
#define NRF_SPI_PORT spi0
#define NRF_SCK_PIN 10  // SPI Clock
#define NRF_MOSI_PIN 11 // SPI MOSI
#define NRF_MISO_PIN 12 // SPI MISO
#define NRF_CSN_PIN 13  // SPI Chip Select
#define NRF_CE_PIN 14   // Chip Enable
#define NODE_ID "01"    // Node identifier

#define MAX_PAYLOAD_SIZE 32  // NRF24L01 max payload size

// Message structure for transmitting data
typedef struct {
    char node_id[3];        // 2 chars + null terminator
    char date[11];          // DD/MM/YYYY + null terminator
    char time[9];           // HH:MM:SS + null terminator
    char latitude[12];      // Including decimal point and sign
    char longitude[12];     // Including decimal point and sign
    float confidence;
} gunshot_message_t;

// GPS Message types we're interested in
#define NMEA_GPRMC "$GPRMC"
#define NMEA_GPGGA "$GPGGA"

// Forward declarations
void init_sync(void);
void safe_uart_puts(const char* str);
void safe_printf(const char* format, ...);
void init_uart(void);
bool init_microphone(void);
void core1_entry(void);
bool test_microphone(void);
static inline void configure_dma(void);
void init_gps(void);
void process_gps(void);
bool parse_nmea_sentence(const char* sentence);
bool wait_for_gps_fix(uint32_t timeout_ms);
void init_nrf24l01(void);
void nrf24l01_send_message(const char* message);
void create_json_message(char* buffer, size_t buffer_size, const gunshot_message_t* msg);

// Global variables and mutex
static mutex_t printf_mutex;
volatile bool core1_ready = false;
volatile bool gunshot_detected = false;

static char gps_buffer[GPS_BUFFER_SIZE];
static uint gps_buffer_pos = 0;
static mutex_t gps_mutex;
static bool valid_gps_data = false;
static float latitude = 0.0f;
static float longitude = 0.0f;

// Audio buffer
static int32_t audio_buffer[SAMPLE_BUFFER_SIZE];

// Include PIO program
#include "inmp441.pio.h"

// DMA configuration
static inline void configure_dma(void) {
    safe_uart_puts("   Starting DMA configuration...\r\n");
    
    // Get default channel configuration
    dma_channel_config c = dma_channel_get_default_config(DMA_CHANNEL);
    
    char buf[64];
    snprintf(buf, sizeof(buf), "   Got default DMA config for channel %d\r\n", DMA_CHANNEL);
    safe_uart_puts(buf);
    
    // Configure channel
    channel_config_set_read_increment(&c, false);  // Don't increment read address (reading from same PIO FIFO)
    channel_config_set_write_increment(&c, true);  // Do increment write address (writing to buffer)
    channel_config_set_transfer_data_size(&c, DMA_SIZE_32);  // Transfer 32-bit words
    channel_config_set_dreq(&c, pio_get_dreq(INMP441_PIO, INMP441_SM, false));  // Pace transfers based on PIO

    dma_channel_configure(
        DMA_CHANNEL,
        &c,
        audio_buffer,                    // Destination pointer
        &INMP441_PIO->rxf[INMP441_SM],  // Source pointer
        SAMPLE_BUFFER_SIZE,              // Number of transfers
        true                            // Start immediately
    );
}

// Initialize mutex for printf synchronization
void init_sync(void) {
    mutex_init(&printf_mutex);
}

// Safe UART output function
void safe_uart_puts(const char* str) {
    mutex_enter_blocking(&printf_mutex);
    uart_puts(UART_ID, str);
    mutex_exit(&printf_mutex);
}

// Safe printf function
void safe_printf(const char* format, ...) {
    mutex_enter_blocking(&printf_mutex);
    va_list args;
    va_start(args, format);
    vprintf(format, args);
    va_end(args);
    mutex_exit(&printf_mutex);
}

// Initialize UART for FTDI communication
void init_uart(void) {
    uart_init(UART_ID, BAUD_RATE);
    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);
    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);
    uart_set_hw_flow(UART_ID, false, false);
    uart_set_format(UART_ID, DATA_BITS, STOP_BITS, PARITY);
    uart_set_fifo_enabled(UART_ID, false);
    uart_puts(UART_ID, "\r\n\nUART Test - If you see this, UART is working!\r\n");
    
    // Initialize model handler
    int init_status = model_init();
    if (init_status != 0) {
        safe_uart_puts("ERROR: Failed to initialize model handler\r\n");
    } else {
        safe_uart_puts("Model handler initialized successfully\r\n");
    }
}

// Override putchar for printf redirection to UART with mutex protection
int putchar(int ch) {
    mutex_enter_blocking(&printf_mutex);
    uart_putc(UART_ID, (char)ch);
    mutex_exit(&printf_mutex);
    return ch;
}

// Test microphone connectivity
bool test_microphone() {
    safe_uart_puts("\r\nStarting microphone test...\r\n");
    safe_uart_puts("\r\nTesting INMP441 Microphone:\r\n");
    safe_uart_puts("1. Checking PIO configuration...\r\n");
    safe_uart_puts("Checking PIO program size...\r\n");
    
    if (!pio_can_add_program(INMP441_PIO, &inmp441_program)) {
        safe_uart_puts("ERROR: Cannot load PIO program - insufficient space\r\n");
        return false;
    }
    
    safe_uart_puts("2. Loading PIO program...\r\n");
    uint offset = pio_add_program(INMP441_PIO, &inmp441_program);
    
    char buf[128];
    snprintf(buf, sizeof(buf), "   Program loaded at offset %u\r\n", offset);
    safe_uart_puts(buf);
    
    safe_uart_puts("3. Initializing GPIO pins...\r\n");
    snprintf(buf, sizeof(buf), "   SCK (BCLK): GPIO %d\r\n", INMP441_SCK_PIN);
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "   WS (LRCLK): GPIO %d\r\n", INMP441_WS_PIN);
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "   SD (DATA):  GPIO %d\r\n", INMP441_SD_PIN);
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "   Sample Rate: %d Hz\r\n", SAMPLE_RATE);
    safe_uart_puts(buf);
    
    // Initialize the PIO state machine
    snprintf(buf, sizeof(buf), "   Initializing PIO state machine %d on PIO%d\r\n", 
             INMP441_SM, (INMP441_PIO == pio0) ? 0 : 1);
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "   Clock frequency: %lu Hz\r\n", clock_get_hz(clk_sys));
    safe_uart_puts(buf);
    
    inmp441_program_init(INMP441_PIO, INMP441_SM, offset, SAMPLE_RATE, INMP441_SD_PIN, INMP441_SCK_PIN);
    safe_uart_puts("   PIO initialization complete\r\n");
    
    safe_uart_puts("4. Configuring DMA...\r\n");
    snprintf(buf, sizeof(buf), "   DMA Channel: %d\r\n", DMA_CHANNEL);
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "   Buffer size: %d samples\r\n", SAMPLE_BUFFER_SIZE);
    safe_uart_puts(buf);
    configure_dma();
    safe_uart_puts("   DMA configuration complete\r\n");
    
    safe_uart_puts("5. Starting audio capture test...\r\n");
    safe_uart_puts("   Please make some noise near the microphone!\r\n\r\n");
    
    uint32_t start_time = to_ms_since_boot(get_absolute_time());
    bool received_audio = false;
    int32_t min_sample = 0x7FFFFFFF;
    int32_t max_sample = -0x7FFFFFFF;
    
    while (to_ms_since_boot(get_absolute_time()) - start_time < MIC_TEST_DURATION_MS) {
        safe_uart_puts("   Waiting for DMA transfer...\r\n");
        dma_channel_wait_for_finish_blocking(DMA_CHANNEL);
        safe_uart_puts("   DMA transfer complete\r\n");
        
        // Process samples
        for (int i = 0; i < DEBUG_SAMPLES; i++) {
            int32_t sample = audio_buffer[i] >> 8;  // Convert to 24-bit
            if (sample != 0) {
                received_audio = true;
            }
            if (sample < min_sample) min_sample = sample;
            if (sample > max_sample) max_sample = sample;
            
            if (i < 8) { // Print first 8 samples
                snprintf(buf, sizeof(buf), "Sample %d: %ld\r\n", i, sample);
                safe_uart_puts(buf);
            }
        }
        
        // Restart DMA
        dma_channel_set_write_addr(DMA_CHANNEL, audio_buffer, true);
        
        if (received_audio) {
            break;  // Got some samples, no need to wait longer
        }
    }
    
    safe_uart_puts("\r\nMicrophone Test Results:\r\n");
    snprintf(buf, sizeof(buf), "- Audio data received: %s\r\n", received_audio ? "YES" : "NO");
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "- Min sample value: %ld\r\n", min_sample);
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "- Max sample value: %ld\r\n", max_sample);
    safe_uart_puts(buf);
    snprintf(buf, sizeof(buf), "- Sample range: %ld\r\n", max_sample - min_sample);
    safe_uart_puts(buf);
    
    if (!received_audio) {
        safe_uart_puts("\r\nERROR: No audio data received. Please check:\r\n");
        safe_uart_puts("1. All connections are secure\r\n");
        safe_uart_puts("2. VDD and GND are properly connected\r\n");
        safe_uart_puts("3. L/R pin is connected to GND\r\n");
        return false;
    }
    
    if (max_sample - min_sample < 1000) {
        safe_uart_puts("\r\nWARNING: Very low audio range detected.\r\n");
        safe_uart_puts("Try making louder sounds near the microphone.\r\n");
    } else {
        safe_uart_puts("\r\nMicrophone test PASSED! â\r\n");
    }
    
    return true;
}

// Initialize INMP441 microphone
bool init_microphone() {
    // First run the test
    if (!test_microphone()) {
        safe_uart_puts("\r\nMicrophone initialization failed! Check connections and try again.\r\n");
        return false;
    }
    
    // No need to reconfigure since test_microphone already set everything up
    return true;
}

// Initialize UART for GPS
void init_gps(void) {
    uart_init(GPS_UART_ID, GPS_BAUD_RATE);
    gpio_set_function(GPS_UART_TX_PIN, GPIO_FUNC_UART);
    gpio_set_function(GPS_UART_RX_PIN, GPIO_FUNC_UART);
    uart_set_hw_flow(GPS_UART_ID, false, false);
    uart_set_format(GPS_UART_ID, GPS_DATA_BITS, GPS_STOP_BITS, GPS_PARITY);
    uart_set_fifo_enabled(GPS_UART_ID, true);
    mutex_init(&gps_mutex);
    safe_uart_puts("GPS UART initialized\r\n");
}

// Process GPS data
void process_gps(void) {
    static uint32_t last_gps_print = 0;
    uint32_t now = to_ms_since_boot(get_absolute_time());
    
    while (uart_is_readable(GPS_UART_ID)) {
        char c = uart_getc(GPS_UART_ID);
        
        // Store character in buffer
        if (gps_buffer_pos < GPS_BUFFER_SIZE - 1) {
            gps_buffer[gps_buffer_pos++] = c;
        }
        
        // If we got a newline, process the sentence
        if (c == '\n') {
            gps_buffer[gps_buffer_pos] = '\0';  // Null terminate
            if (parse_nmea_sentence(gps_buffer)) {
                mutex_enter_blocking(&gps_mutex);
                valid_gps_data = true;
                
                // Print location every 2 seconds if valid
                if (now - last_gps_print > 2000) {
                    char buf[128];
                    snprintf(buf, sizeof(buf), "%.6f, %.6f\r\n", latitude, longitude);
                    safe_uart_puts(buf);
                    last_gps_print = now;
                }
                mutex_exit(&gps_mutex);
            }
            gps_buffer_pos = 0;  // Reset buffer
        }
    }
}

// Parse NMEA sentence
bool parse_nmea_sentence(const char* sentence) {
    // Check for GPRMC sentence (contains position and status)
    if (strncmp(sentence, NMEA_GPRMC, 6) == 0) {
        char status = 'V';
        float lat = 0.0f, lon = 0.0f;
        char ns = 'N', ew = 'E';
        
        // Simple parsing - you might want to use a more robust parser
        if (sscanf(sentence, "$GPRMC,%*[^,],%c,%f,%c,%f,%c", &status, &lat, &ns, &lon, &ew) >= 5) {
            
            if (status == 'A') {  // Data is valid
                char buf[128];
                snprintf(buf, sizeof(buf), "Raw GPS: Lat=%f %c, Lon=%f %c\r\n", lat, ns, lon, ew);
                safe_uart_puts(buf);
                
                // Convert DDMM.MMMM to decimal degrees for latitude
                float lat_deg = (int)(lat / 100);        // Extract DD from DDMM.MMMM
                float lat_min = lat - (lat_deg * 100);   // Extract MM.MMMM
                float final_lat = lat_deg + (lat_min / 60);
                if (ns == 'S') final_lat = -final_lat;
                
                // Convert DDDMM.MMMM to decimal degrees for longitude
                float lon_deg = (int)(lon / 100);        // Extract DDD from DDDMM.MMMM
                float lon_min = lon - (lon_deg * 100);   // Extract MM.MMMM
                float final_lon = lon_deg + (lon_min / 60);
                if (ew == 'W') final_lon = -final_lon;
                
                // Debug print the conversion steps
                snprintf(buf, sizeof(buf), "Conversion: Lat=%fÂ° (deg=%f min=%f), Lon=%fÂ° (deg=%f min=%f)\r\n", 
                        final_lat, lat_deg, lat_min, final_lon, lon_deg, lon_min);
                safe_uart_puts(buf);
                
                mutex_enter_blocking(&gps_mutex);
                latitude = final_lat;
                longitude = final_lon;
                mutex_exit(&gps_mutex);
                return true;
            }
        }
    }
    return false;
}

// Wait for GPS fix with timeout
bool wait_for_gps_fix(uint32_t timeout_ms) {
    uint32_t start_time = to_ms_since_boot(get_absolute_time());
    safe_uart_puts("Waiting for GPS fix...\r\n");
    
    while (to_ms_since_boot(get_absolute_time()) - start_time < timeout_ms) {
        process_gps();
        
        mutex_enter_blocking(&gps_mutex);
        bool has_fix = valid_gps_data;
        mutex_exit(&gps_mutex);
        
        if (has_fix) {
            safe_uart_puts("GPS fix acquired!\r\n");
            return true;
        }
        
        // Show progress
        if ((to_ms_since_boot(get_absolute_time()) - start_time) % 1000 == 0) {
            safe_uart_puts(".");
        }
        
        sleep_ms(100);  // Don't busy-wait
    }
    
    safe_uart_puts("\r\nGPS fix timeout! Check GPS module connections.\r\n");
    return false;
}

// Initialize NRF24L01 module
void init_nrf24l01(void) {
    // Reset chip
    gpio_init(NRF_CE_PIN);
    gpio_set_dir(NRF_CE_PIN, GPIO_OUT);
    gpio_put(NRF_CE_PIN, false);
    sleep_ms(10);
    
    // Configure SPI
    spi_init(NRF_SPI_PORT, 4000000);  // 4 MHz
    gpio_set_function(NRF_SCK_PIN, GPIO_FUNC_SPI);
    gpio_set_function(NRF_MOSI_PIN, GPIO_FUNC_SPI);
    gpio_set_function(NRF_MISO_PIN, GPIO_FUNC_SPI);
    
    // Configure CSN pin
    gpio_init(NRF_CSN_PIN);
    gpio_set_dir(NRF_CSN_PIN, GPIO_OUT);
    gpio_put(NRF_CSN_PIN, true);  // Deselect
    
    // Configure CE pin
    gpio_init(NRF_CE_PIN);
    gpio_set_dir(NRF_CE_PIN, GPIO_OUT);
    gpio_put(NRF_CE_PIN, false);  // Power down
    
    // Give some time for the module to settle
    sleep_ms(100);
    
    safe_uart_puts("NRF24L01 module initialized\r\n");
}

// Send message via NRF24L01
void nrf24l01_send_message(const char* message) {
    gpio_put(NRF_CSN_PIN, false);  // Select the NRF24L01
    sleep_us(10);
    
    // Write message payload
    for (size_t i = 0; i < strlen(message); i++) {
        spi_write_blocking(NRF_SPI_PORT, (const uint8_t*)&message[i], 1);
    }
    
    gpio_put(NRF_CSN_PIN, true);   // Deselect the NRF24L01
    
    safe_uart_puts("Message sent via NRF24L01\r\n");
}

// Create JSON message from data
void create_json_message(char* buffer, size_t buffer_size, const gunshot_message_t* msg) {
    snprintf(buffer, buffer_size, 
            "{\"node_id\":\"%s\",\"date\":\"%s\",\"time\":\"%s\",\"latitude\":\"%s\",\"longitude\":\"%s\",\"confidence\":%.2f}",
            msg->node_id, msg->date, msg->time, msg->latitude, msg->longitude, msg->confidence);
}

// Core 1 entry point - Audio processing
void core1_entry() {
    safe_uart_puts("\r\nCore 1: Starting...\r\n");
    sleep_ms(100); // Give time for UART message
    
    safe_uart_puts("Core 1: Initializing microphone...\r\n");
    sleep_ms(100); // Give time for UART message
    
    // Initialize microphone
    safe_uart_puts("Core 1: Starting microphone initialization...\r\n");
    bool init_success = init_microphone();
    safe_uart_puts("Core 1: Microphone initialization attempt complete\r\n");
    
    if (!init_success) {
        safe_uart_puts("Core 1: Microphone initialization failed\r\n");
        safe_uart_puts("Core 1: Check hardware connections and try again\r\n");
        core1_ready = true;  // Signal core0 even on failure so it doesn't hang
        while (true) {
            gpio_put(LED_PIN, true);   // Error indication pattern
            sleep_ms(100);
            gpio_put(LED_PIN, false);
            sleep_ms(900);             // Blink once per second to show core is alive
        }
    }
    
    safe_uart_puts("Core 1: Microphone initialized successfully\r\n");
    core1_ready = true;  // Signal core0 that we're ready
    
    while (true) {
        // Wait for DMA transfer to complete
        dma_channel_wait_for_finish_blocking(DMA_CHANNEL);
        
        // Process audio data using the model
        bool detection = model_process_audio(audio_buffer, SAMPLE_BUFFER_SIZE);
        float confidence = model_get_confidence();
        
        // Print amplitude level every 100ms
        static uint32_t last_print = 0;
        uint32_t now = to_ms_since_boot(get_absolute_time());
        if (now - last_print > 100) {
            char buf[64];
            snprintf(buf, sizeof(buf), "Confidence: %.2f\r\n", confidence);
            safe_uart_puts(buf);
            last_print = now;
        }

        // Map confidence to LED brightness
        uint8_t led_brightness = (uint8_t)(confidence * 255);
        gpio_put(LED_PIN, led_brightness > 50);
        
        // If detection threshold exceeded, trigger gunshot detection
        if (detection) {
            gunshot_detected = true;
            char buf[64];
            snprintf(buf, sizeof(buf), "GUNSHOT DETECTED! Confidence: %.2f\r\n", confidence);
            safe_uart_puts(buf);
            
            // Prepare and send message via NRF24L01
            gunshot_message_t msg;
            strncpy(msg.node_id, NODE_ID, sizeof(msg.node_id) - 1);
            msg.node_id[sizeof(msg.node_id) - 1] = '\0';  // Ensure null termination
            
            // Get current time
            time_t now = time(NULL);
            struct tm *t = localtime(&now);
            strftime(msg.date, sizeof(msg.date), "%d/%m/%Y", t);
            strftime(msg.time, sizeof(msg.time), "%H:%M:%S", t);
            
            // Set latitude, longitude, and confidence
            snprintf(msg.latitude, sizeof(msg.latitude), "%.6f", latitude);
            snprintf(msg.longitude, sizeof(msg.longitude), "%.6f", longitude);
            msg.confidence = confidence;
            
            // Create JSON message
            char json_buffer[256];
            create_json_message(json_buffer, sizeof(json_buffer), &msg);
            
            // Send message
            nrf24l01_send_message(json_buffer);
            
            sleep_ms(1000); // Prevent multiple detections
            gunshot_detected = false;
        }
        
        // Restart DMA transfer
        dma_channel_set_write_addr(DMA_CHANNEL, audio_buffer, true);
    }
}

// Core 0 entry point - LED control
int main() {
    // Initialize synchronization first
    init_sync();
    
    // Initialize LED for visual debugging
    gpio_init(LED_INBUILT_IN);
    gpio_set_dir(LED_INBUILT_IN, GPIO_OUT);
    gpio_put(LED_INBUILT_IN, true);  // Turn on built-in LED
    
    // Initialize UART
    init_uart();
    sleep_ms(1000); // Give UART time to stabilize
    
    // Initialize external LED
    gpio_init(LED_PIN);
    gpio_set_dir(LED_PIN, GPIO_OUT);
    
    safe_uart_puts("\r\n=== Program Starting ===\r\n");
    safe_uart_puts("Initializing...\r\n");
    
    // Launch Core 1
    safe_uart_puts("Starting Core 1...\r\n");
    multicore_launch_core1(core1_entry);
    
    // Wait for Core 1 to initialize with timeout
    uint32_t start_time = to_ms_since_boot(get_absolute_time());
    while (!core1_ready) {
        // Blink LED while waiting
        gpio_put(LED_INBUILT_IN, true);
        sleep_ms(100);
        gpio_put(LED_INBUILT_IN, false);
        sleep_ms(100);
        
        // Timeout after 10 seconds
        if (to_ms_since_boot(get_absolute_time()) - start_time > 10000) {
            safe_uart_puts("ERROR: Core 1 initialization timeout!\r\n");
            break;
        }
    }
    
    if (core1_ready) {
        safe_uart_puts("Core 1 initialized successfully\r\n");
    }
    
    // Initialize GPS
    init_gps();
    safe_uart_puts("Starting GPS monitoring...\r\n");
    
    // Wait for initial GPS fix
    wait_for_gps_fix(30000);  // 30 seconds timeout for GPS fix
    
    // Initialize NRF24L01
    init_nrf24l01();
    
    // Main loop
    while (true) {
        // Process GPS data
        process_gps();
        
        // Handle gunshot detection with last known position
        if (gunshot_detected) {
            mutex_enter_blocking(&gps_mutex);
            bool has_gps = valid_gps_data;
            float lat = latitude;
            float lon = longitude;
            mutex_exit(&gps_mutex);
            
            char buf[256];
            if (has_gps) {
                snprintf(buf, sizeof(buf), "GUNSHOT DETECTED at Last Known Location: %.6f, %.6f\r\n",
                        lat, lon);
            } else {
                snprintf(buf, sizeof(buf), "GUNSHOT DETECTED! (GPS location not available)\r\n");
            }
            safe_uart_puts(buf);
            
            gpio_put(LED_PIN, true);
            sleep_ms(1000);
            gpio_put(LED_PIN, false);
        }
        
        // Heartbeat LED
        gpio_put(LED_INBUILT_IN, true);
        sleep_ms(100);
        gpio_put(LED_INBUILT_IN, false);
        sleep_ms(400);  // Shorter delay to check GPS more frequently
    }
    
    return 0;  // Never reached
}